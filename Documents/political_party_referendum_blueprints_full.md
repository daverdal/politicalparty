
# Political Party & Referendum System — Complete Blueprint Pack (Cursor-ready)
**Filename:** `political_party_referendum_blueprints_full.md`  
**Generated by:** ChatGPT (GPT-5 Thinking mini)  
**Date:** 2025-12-08

---

## Purpose
A Cursor-ready, developer-focused blueprint pack that adds advanced civic features to your Political Party Game. This single document contains implementation notes, schemas, Cypher queries, API endpoints, UI designs, background jobs, and testing guidance for:

1. Notifications System  
2. Local Points System  
3. Local Badges  
4. Community Challenges  
5. Delegate Mode  
6. Referendum System (full)  
7. Privacy / Anonymity Modes  
8. Plugin Architecture  
9. Data Export System (CSV/JSON/API)  
10. Constitution-aware Governance Rules  

Design goals:
- Minimal schema invasiveness
- Clear API contract for Cursor to implement
- Real-time UX where useful, with scalable fallbacks
- Auditability and configurable privacy
- Extensible plugin pattern for parties/organizations

---

## Contents
- Overview & Core Data Model
- Feature-by-feature blueprints
  - schema and migrations
  - Cypher examples
  - REST/WebSocket endpoints
  - UI/UX notes
  - Background jobs
  - Testing checklist
- Appendix: sample code snippets

---

# Core Assumptions (Existing domain model)
Adjust names to match your schema. Typical entities:
```
User { id, name, ridingId, isDelegate?, verified?, points, createdAt, ... }
Idea { id, authorId, title, body, points, createdAt, ... }
Riding { id, name, province, type, ... }
Like relationship (User)-[:LIKED {createdAt}]->(Idea)
Nomination { id, nominatorId, nomineeId, createdAt }
```

We'll add lightweight nodes/tables for Notifications, Badges, Boosts, BoostHistory, ReferendumQuestion, Argument, Boost, Challenge, AuditLog where necessary.

---

# 1. Notifications System (expanded)

## Goals
Deliver near-real-time notifications for likes, badges, boosts, referendum events, rank changes, and challenge events, across in-app, email, and optionally push.

## Schema (relational preferred for scale)
Table: `notifications`
- `id` UUID PK
- `user_id` UUID
- `type` ENUM('LIKE','BADGE','BOOST','RANK_CHANGE','REF_OPEN','REF_CLOSE','CHALLENGE','DELEGATE_ALERT',...)
- `payload` JSONB
- `read` boolean DEFAULT false
- `created_at` timestamptz
- `expires_at` timestamptz NULLABLE

If using Neo4j:
```
(:Notification { id, userId, type, payload, read, createdAt, expiresAt })
```

## Event triggers
- LIKE → notify idea author
- BADGE → notify user
- BOOST → notify idea author
- REFERENDUM open/close → notify followers / subscribers
- RANK_CHANGE crossing thresholds → notify user
- CHALLENGE reward → notify participants

## Delivery
- WebSocket channel per-user: `ws://.../notifications?auth=...`
  - Events: `notification:received`, `notification:read`, `notification:bulk_read`
- Fallback: REST `GET /api/users/:id/notifications?limit=50&unreadOnly=true`
- Email/PUSH: offload to async worker (SES, SendGrid, FCM/APNS)

## UI
- Transient top-right red pop-up with short message; auto-dismiss in 3–6s.
- Bell icon with unread count; dropdown shows up to 20 latest, with "Mark all read".
- Notifications page for history and settings.
- Per-user notification settings (in-app, email, push; digest frequency).

## Example payload
```json
{
  "type":"LIKE",
  "summary":"Alice liked your idea 'Free WiFi in Town Hall'",
  "payload": {"ideaId":"...", "likerId":"..."}
}
```

---

# 2. Local Points System

## Purpose
Track points for contributors localized by riding/town/First Nation and produce local leaderboards and analytics.

## Data & computation approach
Two approaches:
1. **Computed on-read** (Cypher) — simple, no denormalization.
2. **Incremental counters** — maintain `localPoints` and `globalPoints` on User nodes for fast reads; update via triggers/jobs on LIKE events.

### Recommended incremental properties (for performance)
- `User.localPointsByRiding` — map keyed by `ridingId` (or create separate `UserLocalPoints(ridingId,userId,points)` table)
- `User.globalPoints` integer

### Cypher (computed)
Local points for a user in their riding:
```cypher
MATCH (u:User {id:$userId})-[:AUTHORED]->(i:Idea)<-[l:LIKED]-(liker:User)
WHERE liker.ridingId = u.ridingId
RETURN COUNT(liker) AS localPoints;
```

Leaderboard:
```cypher
MATCH (u:User)-[:AUTHORED]->(i:Idea)<-[l:LIKED]-(liker:User)
WHERE u.ridingId = $ridingId AND liker.ridingId = $ridingId
WITH u, COUNT(liker) AS localPoints
RETURN u {id:u.id, name:u.name, avatar:u.avatar}, localPoints
ORDER BY localPoints DESC
LIMIT $limit;
```

## Backend endpoints
- `GET /api/ridings/:ridingId/local-leaderboard?limit=10`
- `GET /api/users/:userId/local-points?ridingId=...`
- `GET /api/users/:userId/local-rank`

## Background jobs & caching
- `job:recalc-local-points` (incremental) — on LIKE event adjust relevant local counter(s).
- `job:cache-local-leaderboards` — run every 5 minutes.

## Anti-abuse
- Rate-limit likes per liker per target (e.g., max 1 like per idea per user).
- Detect clusters of new accounts liking same target — flag for review.

---

# 3. Local Badges

## Purpose
Award visible recognition for local and global achievement.

## Badge types (examples)
- Local Bronze / Silver / Gold / Champion
- Global Bronze / Silver / Gold / Legend
- Debate Master (X upvoted arguments)
- Delegate Star (delegate-specific)
- Seasonal / Event badges

## Storage
- `Badge` table: `id, user_id, type, level, metadata, awarded_at`
Or node `(:Badge { ... })`

## Award logic
Award on:
- LIKE creation (check thresholds)
- Periodic job (recalc missed thresholds)
- Admin grant

Example Cypher awarding:
```cypher
MATCH (u:User {id:$userId})-[:AUTHORED]->(i:Idea)<-[l:LIKED]-(liker:User)
WHERE liker.ridingId = u.ridingId
WITH u, COUNT(liker) AS localPoints
WHERE localPoints >= 75
MERGE (b:Badge {userId:u.id, type:'local', level:'silver'})
ON CREATE SET b.awardedAt = datetime();
```

## UI
- Badge shelf on profile.
- Tooltip with progress bars toward next tier.
- Notifications when a badge is earned.

---

# 4. Community Challenges

## Goals
Drive engagement with short-term objectives and friendly competition.

## Sample challenge types
- Post Challenge: create X ideas in 7 days
- Debate Challenge: write Y arguments and get Z likes
- Local Rally: get top localPoints in riding this week

## Schema
`Challenge { id, title, description, rulesJSON, startAt, endAt, rewardBadgeId, scope (global|riding), createdBy }`
`ChallengeParticipation {id, challengeId, userId, progressJSON, completedAt}`

## Enforcement & scoring
- Rules described in JSON (e.g., `{ action: "postIdea", count: 3, withinDays:7 }`)
- Worker evaluates progress every 5 minutes or on relevant events.

## UI
- Challenges page showing active, upcoming, and completed challenges.
- Progress bar on user profile and challenge details.

---

# 5. Delegate Mode

## Use-cases
Convention delegates, verified members, secure internal votes.

## Identity & Verification
- `User.verified = true` with `verificationMethod` enum (email, ID, in-person code)
- Optional `DelegateProfile` with `delegationId`, `assignedRiding`, `pinHash`, `deviceFingerprint`

## Secure voting
- Two-factor: PIN + device token or OTP
- Voting session tied to `delegationSessionId`, logged in audit

## Schema
`Delegate { userId, delegateId, verifiedAt, ridingId, credentialHash, allowedVotes }`

## Voting endpoint
- `POST /api/delegates/:delegateId/vote` body `{ motionId, choice, pin }`
Server verifies pin and device, writes `Vote` record and audit entry.

## Auditability
- `AuditLog` table for every delegate action: `{id, userId, action, payload, createdAt, ip, deviceId}`

## UI
- Delegate dashboard, verified badge, secure vote dialog, limited attempts.

---

# 6. Referendum System (Full)

## Overview
Add `ReferendumQuestion` and `Argument` as first-class entities. Support posting, arguing, scoring, and aggregated dashboards with local/regional heatmaps.

## Entities
- `ReferendumQuestion { id, title, body, postedBy, scope (province|riding|state), opensAt, closesAt, status, version }`
- `Argument { id, referId, authorId, side ('pro'|'con'|'neutral'), body, points, createdAt }`
- Reuse `Like` for arguments. Optionally `Endorse` for stronger signal.

## Lifecycle
- Draft → Published → Open → Closed → Archived
- Versioning with `version` and `publishedAt`

## Permissions
- Creation: Admins/Moderators (or verified orgs). Optionally allow public proposals that must be approved.
- Posting arguments: registered users (or verified delegates for official referendums)
- Voting/endorsement: registered users; optional verified-only mode for official tallies.

## Argument Scoring Engine
Weighted score example:
```
score = likes * 1 + endorsements * 5 + comments * 0.5 + authorLocalPoints * 0.01
```
Provide parameters in a config table.

### Cypher: Rank arguments by recent weighted score
```cypher
MATCH (a:Argument {referId:$referId})<-[:LIKED]-(liker:User)
OPTIONAL MATCH (a)<-[:ENDORSED]-()
WITH a, COUNT(liker) AS likes, SIZE((a)<-[:ENDORSED]-()) AS endorses
OPTIONAL MATCH (author:User {id:a.authorId})
RETURN a, (likes * 1) + (endorses * 5) + (author.points * 0.01) AS score
ORDER BY score DESC;
```

## Referendum dashboards
- Participation rate by riding (unique participants / eligible members)
- Pro/Con heatmap by riding
- Top arguments per riding

## Verification & Audit Logs
- For official referendums, require verified accounts, and store immutable logs:
  - `ReferendumVote { id, referId, userId, vote, createdAt, verificationMethod }`
  - All actions write to `AuditLog` with cryptographic hash if desired for tamper-evidence.

## UI
- Referendum page: question header, timeline, participation CTA
- Tabs: Overview, Arguments (Pro/Con/Neutral), Heatmap, Stats, Documents
- Argument cards: show side, score, local counts, badges on authors

---

# 7. Privacy / Anonymity Modes

## Modes
1. **Public** — default; actions tied to user.
2. **Pseudonymous** — show display name, but hide real name to other users; admin can map.
3. **Anonymous (limited)** — user actions shown as "Anonymous #ID" with rate-limits and moderation; only retained as linked to user in DB for audit.

## Implementation
- `ActionVisibility` enum on actions: `PUBLIC`, `PSEUDO`, `ANON`
- For anonymity: store `anonymousAlias` per user per referendum (so a user can appear consistent but anonymous).
- Admins keep mapping securely; for legal requests, mapping retrievable with audit.

## Anti-abuse on anonymous
- Stronger rate limits, more aggressive bot detection.
- Require account age or minimal reputation to use ANON.
- Keep full audit logs with higher retention.

---

# 8. Plugin Architecture

## Goals
Enable organizations (parties, unions) to add custom modules, rulesets, or UI components without forking core.

## Key concepts
- **Plugin manifest**: JSON declaring hooks and capabilities.
- **Hook points**: server-side (events: onLike, onIdeaCreate, onReferendumOpen), client-side (UI injection points).
- **Sandboxing**: Plugins run in isolated processes or serverless functions; limited DB access via API.
- **Permissions**: plugins scoped to organization.

## Manifest example
```json
{
  "id":"party-custom-1",
  "name":"SaskParty Branding",
  "version":"1.0",
  "hooks":["onReferendumOpen","onIdeaListRender"],
  "uiAssets":["/plugins/saskparty/header.js"],
  "permissions":["read:ideas","write:notifications"]
}
```

## Server-side hooks
- Event bus (Kafka/Redis) dispatches events.
- Plugins subscribe to events; they receive sanitized payloads and can call platform APIs.

## Client-side UI injection
- Plugin host page loads plugin asset URLs specified in manifest.
- Only authorized plugin manifests loaded per tenant.

## Example plugin use-cases
- Party-specific badge sets
- Custom voting rules for a convention
- Integration with member registry (CSV upload)

---

# 9. Data Export System

## Goals
Provide CSV/JSON exports and API endpoints for reporting, legal requests, or presentation decks.

## Exports
- `GET /api/export/referendum/:id?format=csv|json&scope=global|riding:{id}`
- `GET /api/export/leaderboard/:ridingId?limit=100&format=csv`

## Security
- Exports containing PII require elevated permissions.
- For large exports, generate asynchronously and provide secure download link (S3 signed URL) with TTL.

## File schemas
- Leaderboard CSV: `rank, userId, displayName, localPoints, globalPoints, ridingId`
- Argument CSV: `id, referId, authorId, side, score, createdAt`

---

# 10. Constitution-aware Governance Rules

## Purpose
Allow the system to enforce organizational governance rules derived from a constitution (e.g., quorum, nomination eligibility, voting thresholds).

## Approach
- Model constitution rules as machine-readable `Rule` objects.
- Use an engine to evaluate rules at key events (nominations, motion passage, delegate eligibility).

## Sample Rule JSON
```json
{
  "id":"quorum-1",
  "scope":"convention",
  "description":"Quorum is 50% of registered delegates",
  "type":"quorum",
  "params":{"requiredPercent":50}
}
```

## Enforcement points
- Before motion scheduling, check quorum rule
- Before accepting nominations, check eligibility rules in constitution
- Voting thresholds evaluated by rule engine (simple DSL or JSON functions)

## DSL & engine
- Start simple: JSON-based rules with a small interpreter.
- If needed, plug in a rules engine (Drools-like) or evaluate via sandboxed JS functions stored as plugin.

## Audit & versioning
- All rule changes versioned and displayed with timestamp and author.
- Rules evaluated against historical snapshots; audits show which rules applied at event time.

---

# 11. Background Jobs & Scaling

## Job List
- `job:notification-dispatcher` (retries, batching)
- `job:recalc-badges`
- `job:cache-leaderboards`
- `job:expire-boosts`
- `job:challenge-evaluator`
- `job:export-generator`

## Scaling notes
- Use Redis for transient counters, rate-limits.
- Use message queue (Kafka/RabbitMQ) for event-driven plugin notifications.
- Use relational DB for notification history and exports for better querying.

---

# 12. Testing Checklist (high-level)
- Unit tests for endpoints
- Integration tests for WebSocket notification flow
- Load tests for leaderboards & trending queries
- Security tests for delegate voting + PIN flows
- Privacy tests for anonymous/pseudonymous modes

---

# 13. Appendix — Sample snippets

## A. Mark like and create notification (pseudo-code)
```cypher
MATCH (u:User {id:$userId}), (i:Idea {id:$ideaId})
CREATE (u)-[:LIKED {createdAt: datetime()}]->(i)
WITH i
MATCH (author:User {id: i.authorId})
CREATE (n:Notification {id: apoc.create.uuid(), userId: author.id, type:'LIKE', payload: {ideaId: i.id, likerId: $userId}, read:false, createdAt:datetime()})
```

## B. Create Referendum (pseudo REST)
```
POST /api/referendums
Body: { title, body, scope, opensAt, closesAt, postedBy }
Auth: admin or org-scoped key
```

## C. Export example (Node)
```js
app.get('/api/export/leaderboard/:ridingId', async (req,res) => {
  const csv = await generateLeaderboardCSV(req.params.ridingId);
  // store on s3 and return signed url
  const url = await uploadAndGetSignedUrl(csv);
  res.json({ url });
});
```

---

# Closing notes
This blueprint pack is intentionally pragmatic — focused on what Cursor needs to implement features quickly and safely. It balances real-time UX with scalable data patterns and includes optional advanced pieces (plugin sandboxing, constitution rule engine) that can be added iteratively.

If you want, I can now:
- Generate this as a **downloadable markdown file** for Cursor (I will save it to `/mnt/data/` and provide a link), or
- Split the pack into multiple files (e.g., `referendum.md`, `delegate_mode.md`, `plugins.md`) if that helps Cursor work in parallel.

Please tell me which you prefer:
- "Generate single file" (default) or
- "Split into modules" (specify which)
